/**
 * Real-Time Calculations Hook
 * React hook for integrating real-time HVAC calculations with 3D Canvas
 * SizeWise Suite - Real-time Calculation Connectivity Implementation
 */

import { useCallback, useEffect, useRef, useState } from 'react';
import { SystemTopologyManager } from '@/lib/system/SystemTopologyManager';
import { RealTimeCalculationEngine, CalculationResult, SystemCalculationResults } from '@/lib/system/RealTimeCalculationEngine';
import { SystemFlowCalculator, SystemFlowAnalysis } from '@/lib/system/SystemFlowCalculator';
import { DuctSegment, Equipment, DuctFitting } from '@/components/3d/types/Canvas3DTypes';
import { createEnhancedDuctSegment, createEnhancedEquipment, createEnhancedDuctFitting } from '@/lib/system/SystemDataUtils';

export interface RealTimeCalculationState {
  isCalculating: boolean;
  lastCalculationTime: Date | null;
  calculationResults: Map<string, CalculationResult>;
  systemAnalysis: SystemFlowAnalysis | null;
  validationErrors: string[];
  validationWarnings: string[];
  systemValid: boolean;
}

export interface RealTimeCalculationActions {
  addSegment: (segment: Omit<DuctSegment, 'flowProperties' | 'connectionRelationships' | 'calculationState'>) => void;
  updateSegment: (segmentId: string, updates: Partial<DuctSegment>) => void;
  removeSegment: (segmentId: string) => void;
  addEquipment: (equipment: Omit<Equipment, 'flowProperties' | 'connectionRelationships' | 'calculationState' | 'operatingConditions'>) => void;
  updateEquipment: (equipmentId: string, updates: Partial<Equipment>) => void;
  removeEquipment: (equipmentId: string) => void;
  addFitting: (fitting: Omit<DuctFitting, 'flowProperties' | 'connectionRelationships' | 'calculationState' | 'pressureLossCoefficient' | 'fittingGeometry' | 'smacnaCompliant' | 'isAutoGenerated'>) => void;
  updateFitting: (fittingId: string, updates: Partial<DuctFitting>) => void;
  removeFitting: (fittingId: string) => void;
  createConnection: (fromElementId: string, toElementId: string, fromConnectionPointId: string, toConnectionPointId: string) => void;
  removeConnection: (connectionId: string) => void;
  triggerCalculation: (elementId?: string) => void;
  triggerSystemCalculation: () => void;
  getElementCalculationResult: (elementId: string) => CalculationResult | null;
  getSystemTopology: () => SystemTopologyManager;
}

export interface UseRealTimeCalculationsOptions {
  autoCalculate?: boolean; // Automatically trigger calculations on changes
  debounceDelay?: number; // Delay before triggering calculations (ms)
  enableValidation?: boolean; // Enable real-time validation
  onCalculationStart?: (elementId: string) => void;
  onCalculationComplete?: (result: CalculationResult) => void;
  onSystemCalculationComplete?: (results: SystemCalculationResults) => void;
  onCalculationError?: (elementId: string, error: string) => void;
  onValidationUpdate?: (errors: string[], warnings: string[]) => void;
}

/**
 * Hook for managing real-time HVAC calculations in the 3D Canvas
 */
export function useRealTimeCalculations(
  options: UseRealTimeCalculationsOptions = {}
): [RealTimeCalculationState, RealTimeCalculationActions] {
  
  const {
    autoCalculate = true,
    debounceDelay = 500,
    enableValidation = true,
    onCalculationStart,
    onCalculationComplete,
    onSystemCalculationComplete,
    onCalculationError,
    onValidationUpdate
  } = options;

  // State
  const [state, setState] = useState<RealTimeCalculationState>({
    isCalculating: false,
    lastCalculationTime: null,
    calculationResults: new Map(),
    systemAnalysis: null,
    validationErrors: [],
    validationWarnings: [],
    systemValid: true
  });

  // Refs for managers
  const topologyManagerRef = useRef<SystemTopologyManager | null>(null);
  const calculationEngineRef = useRef<RealTimeCalculationEngine | null>(null);
  const flowCalculatorRef = useRef<SystemFlowCalculator | null>(null);

  // Initialize managers
  useEffect(() => {
    // Initialize topology manager
    topologyManagerRef.current = new SystemTopologyManager(
      (changeType, nodeId) => {
        // Handle topology changes
        if (autoCalculate) {
          calculationEngineRef.current?.triggerCalculation(nodeId, changeType as any);
        }
      },
      (nodeId, results) => {
        // Handle calculation completion
        setState(prev => ({
          ...prev,
          calculationResults: new Map(prev.calculationResults).set(nodeId, {
            elementId: nodeId,
            success: true,
            flowProperties: results,
            warnings: [],
            errors: [],
            calculationTime: 0
          })
        }));
      },
      (validationResult) => {
        // Handle validation updates
        const errors = validationResult.errors.map(e => e.message);
        const warnings = validationResult.warnings.map(w => w.message);
        
        setState(prev => ({
          ...prev,
          validationErrors: errors,
          validationWarnings: warnings,
          systemValid: validationResult.isValid
        }));
        
        onValidationUpdate?.(errors, warnings);
      }
    );

    // Initialize calculation engine
    calculationEngineRef.current = new RealTimeCalculationEngine(
      topologyManagerRef.current,
      {
        debounceDelay,
        onCalculationStart: (elementId) => {
          setState(prev => ({ ...prev, isCalculating: true }));
          onCalculationStart?.(elementId);
        },
        onCalculationComplete: (result) => {
          setState(prev => ({
            ...prev,
            calculationResults: new Map(prev.calculationResults).set(result.elementId, result)
          }));
          onCalculationComplete?.(result);
        },
        onSystemCalculationComplete: (results) => {
          setState(prev => ({
            ...prev,
            isCalculating: false,
            lastCalculationTime: new Date(),
            calculationResults: results.results
          }));
          
          // Trigger system flow analysis
          if (flowCalculatorRef.current) {
            const systemAnalysis = flowCalculatorRef.current.analyzeSystemFlow();
            setState(prev => ({ ...prev, systemAnalysis }));
          }
          
          onSystemCalculationComplete?.(results);
        },
        onCalculationError: (elementId, error) => {
          setState(prev => ({ ...prev, isCalculating: false }));
          onCalculationError?.(elementId, error);
        }
      }
    );

    // Initialize flow calculator
    flowCalculatorRef.current = new SystemFlowCalculator(topologyManagerRef.current);

  }, [autoCalculate, debounceDelay, onCalculationStart, onCalculationComplete, onSystemCalculationComplete, onCalculationError, onValidationUpdate]);

  // Actions
  const actions: RealTimeCalculationActions = {
    addSegment: useCallback((segmentData) => {
      if (!topologyManagerRef.current) return;
      
      const enhancedSegment = createEnhancedDuctSegment(
        segmentData.id,
        segmentData.start,
        segmentData.end,
        segmentData.shape,
        segmentData.type,
        segmentData.material,
        {
          width: segmentData.width,
          height: segmentData.height,
          diameter: segmentData.diameter
        }
      );

      topologyManagerRef.current.addNode(enhancedSegment);
    }, []),

    updateSegment: useCallback((segmentId, updates) => {
      if (!topologyManagerRef.current) return;
      
      const node = topologyManagerRef.current.getNodes().get(segmentId);
      if (node && node.type === 'segment') {
        const updatedSegment = { ...node.element, ...updates } as DuctSegment;
        topologyManagerRef.current.updateNode(segmentId, updatedSegment);
      }
    }, []),

    removeSegment: useCallback((segmentId) => {
      if (!topologyManagerRef.current) return;
      topologyManagerRef.current.removeNode(segmentId);
    }, []),

    addEquipment: useCallback((equipmentData) => {
      if (!topologyManagerRef.current) return;
      
      const enhancedEquipment = createEnhancedEquipment(
        equipmentData.id,
        equipmentData.type,
        equipmentData.position,
        equipmentData.properties.cfmCapacity,
        equipmentData.properties.staticPressureCapacity,
        equipmentData.dimensions
      );
      
      topologyManagerRef.current.addNode(enhancedEquipment);
    }, []),

    updateEquipment: useCallback((equipmentId, updates) => {
      if (!topologyManagerRef.current) return;

      const node = topologyManagerRef.current.getNodes().get(equipmentId);
      if (node && node.type === 'equipment') {
        const updatedEquipment = { ...node.element, ...updates } as Equipment;
        topologyManagerRef.current.updateNode(equipmentId, updatedEquipment);
      }
    }, []),

    removeEquipment: useCallback((equipmentId) => {
      if (!topologyManagerRef.current) return;
      topologyManagerRef.current.removeNode(equipmentId);
    }, []),

    addFitting: useCallback((fittingData) => {
      if (!topologyManagerRef.current) return;

      const enhancedFitting = createEnhancedDuctFitting(
        fittingData.id,
        fittingData.type,
        fittingData.position,
        fittingData.inlet,
        fittingData.outlet,
        fittingData.material
      );

      topologyManagerRef.current.addNode(enhancedFitting);
    }, []),

    updateFitting: useCallback((fittingId, updates) => {
      if (!topologyManagerRef.current) return;
      
      const node = topologyManagerRef.current.getNodes().get(fittingId);
      if (node && node.type === 'fitting') {
        const updatedFitting = { ...node.element, ...updates } as DuctFitting;
        topologyManagerRef.current.updateNode(fittingId, updatedFitting);
      }
    }, []),

    removeFitting: useCallback((fittingId) => {
      if (!topologyManagerRef.current) return;
      topologyManagerRef.current.removeNode(fittingId);
    }, []),

    createConnection: useCallback((fromElementId, toElementId, fromConnectionPointId, toConnectionPointId) => {
      if (!topologyManagerRef.current) return;
      
      topologyManagerRef.current.createConnection(
        fromElementId,
        toElementId,
        fromConnectionPointId,
        toConnectionPointId
      );
    }, []),

    removeConnection: useCallback((connectionId) => {
      if (!topologyManagerRef.current) return;
      topologyManagerRef.current.removeConnection(connectionId);
    }, []),

    triggerCalculation: useCallback((elementId) => {
      if (!calculationEngineRef.current) return;

      if (elementId) {
        calculationEngineRef.current.triggerCalculation(elementId);
      } else {
        calculationEngineRef.current.triggerSystemCalculation();
      }
    }, []),

    triggerSystemCalculation: useCallback(() => {
      if (!calculationEngineRef.current) return;
      calculationEngineRef.current.triggerSystemCalculation();
    }, []),

    getElementCalculationResult: useCallback((elementId) => {
      return state.calculationResults.get(elementId) || null;
    }, [state.calculationResults]),

    getSystemTopology: useCallback(() => {
      return topologyManagerRef.current!;
    }, [])
  };

  return [state, actions];
}

/**
 * Hook for accessing calculation results for a specific element
 */
export function useElementCalculationResult(elementId: string, calculationResults: Map<string, CalculationResult>) {
  return calculationResults.get(elementId) || null;
}

/**
 * Hook for monitoring system calculation status
 */
export function useSystemCalculationStatus(state: RealTimeCalculationState) {
  const totalElements = state.calculationResults.size;
  const calculatedElements = Array.from(state.calculationResults.values()).filter(r => r.success).length;
  const failedElements = Array.from(state.calculationResults.values()).filter(r => !r.success).length;
  
  return {
    totalElements,
    calculatedElements,
    failedElements,
    calculationProgress: totalElements > 0 ? (calculatedElements / totalElements) * 100 : 0,
    isCalculating: state.isCalculating,
    lastCalculationTime: state.lastCalculationTime,
    systemValid: state.systemValid,
    hasErrors: state.validationErrors.length > 0,
    hasWarnings: state.validationWarnings.length > 0
  };
}
